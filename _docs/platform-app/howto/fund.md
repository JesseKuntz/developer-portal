---
title: Fund
subtitle:
tags: [platform app, platform application, live app, ledger live app]
category: Platform Application
toc: true
layout: doc
---

## Introduction

To secure the funding of the card, Ledger developed an exchange app that you are able to call in your iframe through the device Ledger Live Widget API. You will have to modify your web service to generate the appropriate request for the exchange app. In this document, we will guide you through this process.

As you can see on the following diagram, there are three interactions between Ledger Live and your iframe. This three interactions are the ones that are needed from your side.  

![Secure funding high level design](../../images/baanx-secure-funding.png "Secure funding high level design")

The three main functions you need for the funding are: 
- List the accounts: `listAccounts`,
- Start the exchange: `initExchange`,
- Complete the exchange (**payload and R,S** in the diagram): `completeExchange`.


## List accounts

List the accounts added by the user on Ledger Live.

[listAccounts](../../classes/#listaccounts):

```json
async listAccounts(): Promise<Account[]> {
    const rawAccounts = await this._request<RawAccount[]>("account.list");

    return rawAccounts.map(deserializeAccount);
  }
```

## Start exchange

Start the exchange process by generating a nonce on Ledger device.

[initExchange](../../classes/#initexchange):

```json
 async initExchange(
    _exchangeType: ExchangeType,
    _partnerName: string
  ): Promise<string> {
    throw new Error("Function is not implemented yet");
  }
```


## Complete exchange

Complete an exchange process by passing by the exchange content and its signature.

[completeExchange](../../classes/#completeexchange):

```json
async completeExchange(
    _exchangePayload: ExchangePayload,
    _payloadSignature: EcdsaSignature,
    _txFeesLevel: FeesLevel
  ): Promise<void> {
    throw new Error("Function is not implemented yet");
  }
```
### Payloads

The **exchangePayload** is a protobuf message containing the transaction data. It is generated by the provider and sent to Ledger Live. 

Your protobuf message should have the following structure: 

```json
message NewFundResponse {
   string    user_id = 1; 
   string    account_name = 2; 
   string    in_currency = 3; 
   bytes     in_amount = 4; 
   string    in_address = 5; 
   bytes    device_transaction_id = 6; 
}
```

Explanation of each fields:
- `user_id`: the client ID.
- `account_name`: the funded account name (example: Card 1234).
- `in_currency`: the currency that the client wants to use to fund.
- `in_amount`: the amount of **in_currency** that the client wants to fund.
- `in_address`: the account of the client.
- `device_transaction_id`: the fund transaction nonce provided by the client at initialization.

Amounts must be in the lowest unit of the coin, encoded into a 16 bytes array in big endian.<br>
Example:
- 1 **BTC** would be `0x5F5E100` (100000000 in hexadecimal). The smallest unit is a **satoshi** which is `10^-8` **BTC**.<br> 
So multiply 1 **BTC** by `10^8` → `0x5F5E100`. <br>
And `0x5F5E100` encoded into a 16 bytes array in big endian is `[0x00, ... 0x00, 0x05, 0xF5, 0xE1, 0x00]`.
- 2 **ETH** would be `0x1BC16D674EC80000` (or 2000000000000000000). The smallest unit is a **wei** which is `10^-18` **ETH**.<br> 
So multiply 2 **ETH** by `10^18` → `0x1BC16D674EC80000`. <br>
And `0x1BC16D674EC80000` encoded into a 16 bytes array in big endian is `[0x00, ... 0x00, 0x1B, 0xC1, 0x6D, 0x67, 0x4E, 0xC8, 0x00, 0x00]`.


**Payloads generation**

How are generated `exchangePayload` and `payloadSignature` ? <br>
Here is a diagram [TO BE UPDATED] to explain this: 

[![Payload and Payload Signature generation diagram](../../images/funding-payload-signature-generation.png)](../../images/funding-payload-signature-generation.png)

- `exchangePayload`: The funding parameters are assembled in a [protobuf](https://developers.google.com/protocol-buffers) message. Then using the protobuf tools you can do a [binary encoding](https://developers.google.com/protocol-buffers/docs/encoding) of the protobuf (Byte Array). Finally, with [base64 encoding](https://en.wikipedia.org/wiki/Base64) you get the `exchangePayload` field.  
- `payloadSignature`: From the binary encoding of the previous [protobuf](https://developers.google.com/protocol-buffers) (Byte Array), you sign it with [ES256](https://ldapwiki.com/wiki/ES256) and your private key to get a Signature Byte Array. Finally, with [base64 encoding](https://en.wikipedia.org/wiki/Base64) you get the `payloadSignature`.

### Input field: nonce

A nonce field will be passed as parameter to secure the funding.<br>
It is a 32 bytes nonce which is generated by the hardware wallet to avoid replay attacks.<br> 
It will be base 64 URL encoded before being sent to the corresponding endpoint.
